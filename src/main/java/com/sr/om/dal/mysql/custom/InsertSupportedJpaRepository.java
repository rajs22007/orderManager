package com.sr.om.dal.mysql.custom;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.NoRepositoryBean;

import java.io.Serializable;

/**
 * When a new entity is saved (inserted) without a custom ID being generated,
 * JPA automatically fires a SELECT statement to get the entity state from the
 * DB, in order to figure out whether to insert or update the entity. It does
 * this because it is not sure whether the entity is already present in the
 * database. For our cases, we are generating the ID and we know for sure that
 * there is no duplicate at the time of insertion. If there is a duplicate, we
 * are fine with failing without upsert happening. To avoid the penalty of the
 * extra SELECT before every INSERT, this custom repository directly calls the
 * underlying EntityManager's persist method which fires a blind insert.
 *
 * 
 */
@NoRepositoryBean
public interface InsertSupportedJpaRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {

    // http://docs.spring.io/spring-data/jpa/docs/current/reference/
    // html/#repositories.custom-behaviour-for-all-repositories

    /**
     * Inserts the specified entity into the database
     * <p>
     * WARNING: Please be careful while using this method. It assumes that the
     * ID is already generated by the caller, and does not perform an upsert. It
     * directly fires an INSERT query on the database and nothing else.
     *
     * @param entity
     *            The entity to be inserted
     */
    void insert(T entity);

    /**
     * Inserts the specified entity into the database and flushes the
     * transaction
     * <p>
     * WARNING: Please be careful while using this method. It assumes that the
     * ID is already generated by the caller, and does not perform an upsert. It
     * directly fires an INSERT query on the database and nothing else.
     *
     * @param entity
     *            The entity to be inserted
     */
    void insertAndFlush(T entity);
    
    T insertAndFlushReturnObj(T entity);
}
